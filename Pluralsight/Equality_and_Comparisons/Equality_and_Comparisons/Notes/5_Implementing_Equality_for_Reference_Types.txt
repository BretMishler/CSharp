For reference types, you have to deal with inheritence
    not a problem for VALUE types because everything is implicitely SEALED

Being SEALED impacts how you can implement "equality"

Why Override Equality (Ref Types)?
    First, theres a good reason NOT to override equality for reference types...
    Devs know and expect how if(a == b) should work

    You might override equality for...

    STRING WRAPPERS
        // class that basically wraps a string
        class FirstName
        {
            private string _value;

        // so may want to implement something like
        if (name1 == name2) {

    MATHEMATICAL TYPES
        class Vector
        {

        // might want to be able to use notation like
        // so may want to implement something like
        if (vector1 == vector2) {

Alternatively...

    Write an equality comparer for your type instead

    EQUALITY COMPARER
        IEqualityComparer<T>

        // canse use == for equality with equality comparers

        if (myEqualityComparer.Equals(obj1, obj2));


Differences from implementing equality for a VALUE TYPE:
    Recall for FoodItem value type in last module
        started by implementing IEquatable<T>.Equals()
    This time, for ref type
        we didnt bother implementing IEquatable<T> because its not useful here
        put equality logic in object.Equals()


DO NOT CHEESE == Operator by doing something like this
(which is COPYING the last line in the obj,Equals() override)

        public static bool operator ==(Food x, Food y)
        {
            //return object.Equals(x, y);
            return this._name == rhs._name && this._group == rhs._group;
        }
WARNING! Even MS Docs get lazy and do the above. Not all of the logic it skips
when compared with:

        public override bool Equals(object obj)
        {
            // 'this' cannot equal null 
            if (obj == null)
                return false;
            if (ReferenceEquals(obj, this))
                return true;
            if (obj.GetType() != this.GetType())
                return false;
            Food rhs = obj as Food;
            return this._name == rhs._name && this._group == rhs._group;
        }

?EXAMPLE: DisplayWhetherEqual(stewedApple, bakedApple);