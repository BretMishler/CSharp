AUTO PROPERTY INITIALIZERS
	
	C# right out of the box could define properties for an object

		public class User
		{
			// Globally Unique Identifier
			public Guid Id
			{
				get { return _id; }
			}

			// backing field
			Guid _id = Guid.NewGuid();
		}


	-----> A few years later ------>
	C# had automatically implemented properties
		backing field was generated by the compiler, which also implemented get; set; logic
		BUT you had to always set the property vals inside explicit constructor in order to initialize an auto property


		public class User
		{
			public Guid Id { get; protected set; }
		}


!!!!
	-----> A few years later ------->
	C# 6 allows for Auto Property Initializers
		You can use an automatically implemented property and still provide the property w/ an initial value w/out a constructor
		
		!! Works very well for data transfer objects (DTO), which typically only have properties to carry data
		(no associated methods or behavior)

		public class User
		{
			// auto property initializer
			public Guid Id { get; } = Guid.NewGuid();
		}


Auto-Property Initializers
	
!!!!
	May be wondering how we could ever change a property like the following (that uses Auto-Property Initialization)
		public string Username { get; protected set; } = String.Empty;
     
		This is what Primary Constructors would help with!
		(ACTUALLY - THE ENDED UP BEING CUT FROM C# 6 AND FUTURE RELEASES UP TO THE POINT OF TIME WHERE I GOOGLED THIS lol)



DICTIONARY INITIALIZERS
	PRE C#6
		Dictionary<string, User> _defaultUsers
			= new Dictionary<string, User>()
			{	//	key,	value
				{"admin", new User("admin")},
				{"guest", new User("guest")}
			};

	POST C#6
		Dictionary<string, User> _defaultUsers
			= new Dictionary<string, User>()
			{	//	key,	value
				["admin"] = new User("admin"),
				["guest"] = new User("guest")
			};

	Subtle differences behind the scenes
		PRE C#6 example, compiler uses dictionary.Add(K, V);
			dictionary.Add("admin", new User("admin"));
		POST C#6 example, compiler will assign V by using K as an index
			dictionary["admin"] = new User("admin");


!!!
Can now use EXTENSION METHODS named 'Add' to
	-make intiializer syntax work for types that are IEnumerable
	-and have some sort of API that allow you to add things into them but havent
		named the method 'Add'



EVENT INITIALIZERS

	ex class
		public class User
		{
			public void Speak()
			{
				if(Speaking != null)
				{
					Speaking(this, new EventArgs());
				}
			}
			public string Name { get; set; }
			public event EventHandler<EventArgs> Speaking;
		}

	ex use
		public class Program
		{
			public static void Main()
			{
				EventHandler<EventArgs> log = (o, e) => Console.Write("hit");

				var user = new User()
				{
					Name = "Scott",
					// wire up speaking event to our own delegate
					Speaking += log
				};
			}
		}


PARAMS AND IENUMERABLE

	Used to have to pass in an ar4ay and receive params int[] numbers
		public static void Main()
		{ 
			var result = Sum(45, 54, 14);
		}

		public int Sum(params IEnumerable<int> numbers)
		{
			return numbers.Sum(n => n);
		}

	Array will force you to convert your Enumerable to a concrete, in-memory data struct
		before you even call the method
	The updated example above will 
		lazily work through sequence and sometimes save on mem and processing.


LITERALS AND SEPERATORS
	Ease of readability

	public class Digits
	{
		public byte Code { get; } = 0b1100;
		public long Length { get; } = 1_000_000_000;
	}